diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index 548311fd..3d47701f 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -111,6 +111,27 @@ config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
 	  you to get a full dynamic cpu frequency capable system by simply
 	  loading your cpufreq low-level hardware driver, using the
 	  'interactive' governor for latency-sensitive workloads.
+ 
+config CPU_FREQ_DEFAULT_GOV_ELEMENTALX
+ 	bool "elementalx"
+ 	select CPU_FREQ_GOV_ELEMENTALX
+ 	select CPU_FREQ_GOV_PERFORMANCE
+ 	help
+ 	  Use the CPUFreq governor 'elementalx' as default.
+ 
+config CPU_FREQ_DEFAULT_GOV_ZZMOOVE
+	bool "zzmoove"
+	select CPU_FREQ_GOV_ZZMOOVE
+	select CPU_FREQ_GOV_PERFORMANCE
+	help
+	  Use the CPUFreq governor 'zzmoove' as default, using predefined
+	  frequency lookup tables and optimized scaling triggers instead of
+	  % frequency steps to get smooth up/downscaling dependant on CPU load.
+
+config CPU_FREQ_DEFAULT_GOV_NIGHTMARE
+ 	bool "nightmare"
+ 	select CPU_FREQ_GOV_NIGHTMARE
+ 	help
 
 endchoice
 
@@ -186,6 +207,33 @@ config CPU_FREQ_GOV_INTERACTIVE
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_ELEMENTALX
+ 	tristate "'elementalx' cpufreq policy governor"
+ 	select CPU_FREQ_TABLE
+ 	help
+ 	  'elementalx' - This driver adds a dynamic cpufreq policy governor.
+ 
+ 	  To compile this driver as a module, choose M here: the
+ 	  module will be called cpufreq_elementalx.
+ 
+ 	  For details, take a look at linux/Documentation/cpu-freq.
+ 
+ 	  If in doubt, say N.
+
+config CPU_FREQ_GOV_ZZMOOVE
+	tristate "'zzmoove' cpufreq governor"
+	depends on CPU_FREQ
+	help
+	  'zzmoove' - based on cpufreq_conservative, using predefined
+	  frequency lookup tables and optimized scaling triggers instead of
+	  % frequency steps to get smooth up/downscaling dependant on CPU load.
+
+	  if in doubt, say N.
+             
+config CPU_FREQ_GOV_NIGHTMARE
+ 	tristate "'nightmare' cpufreq governor"
+ 	depends on CPU_FREQ 
+
 config CPU_FREQ_GOV_CONSERVATIVE
 	tristate "'conservative' cpufreq governor"
 	depends on CPU_FREQ
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index e4c007d4..d08b40cf 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -15,8 +15,10 @@ obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
 obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
+obj-$(CONFIG_CPU_FREQ_GOV_ELEMENTALX)	+= cpufreq_elementalx.o
 obj-$(CONFIG_CPU_FREQ_GOV_COMMON)		+= cpufreq_governor.o
-
+obj-$(CONFIG_CPU_FREQ_GOV_ZZMOOVE)      += cpufreq_zzmoove.o
+obj-$(CONFIG_CPU_FREQ_GOV_NIGHTMARE)	+= cpufreq_nightmare.o
 obj-$(CONFIG_CPUFREQ_DT)		+= cpufreq-dt.o
 
 ##################################################################################
diff --git a/drivers/cpufreq/cpufreq_governor.c b/drivers/cpufreq/cpufreq_governor.c
index 1b44496b..43c916d0 100644
--- a/drivers/cpufreq/cpufreq_governor.c
+++ b/drivers/cpufreq/cpufreq_governor.c
@@ -35,6 +35,8 @@ void dbs_check_cpu(struct dbs_data *dbs_data, int cpu)
 	struct cpu_dbs_common_info *cdbs = dbs_data->cdata->get_cpu_cdbs(cpu);
 	struct od_dbs_tuners *od_tuners = dbs_data->tuners;
 	struct cs_dbs_tuners *cs_tuners = dbs_data->tuners;
+	struct ex_dbs_tuners *ex_tuners = dbs_data->tuners;
+	struct zz_dbs_tuners *zz_tuners = dbs_data->tuners;
 	struct cpufreq_policy *policy;
 	unsigned int sampling_rate;
 	unsigned int max_load = 0;
@@ -55,6 +57,12 @@ void dbs_check_cpu(struct dbs_data *dbs_data, int cpu)
 		sampling_rate *= od_dbs_info->rate_mult;
 
 		ignore_nice = od_tuners->ignore_nice_load;
+	} else if (dbs_data->cdata->governor == GOV_ELEMENTALX) {
+ 		sampling_rate = ex_tuners->sampling_rate;
+ 		ignore_nice = ex_tuners->ignore_nice_load;
+	} else if (dbs_data->cdata->governor == GOV_ZZMOOVE) {
+		sampling_rate = zz_tuners->sampling_rate;
+		ignore_nice = zz_tuners->ignore_nice_load;
 	} else {
 		sampling_rate = cs_tuners->sampling_rate;
 		ignore_nice = cs_tuners->ignore_nice_load;
@@ -233,6 +241,12 @@ static void set_sampling_rate(struct dbs_data *dbs_data,
 	if (dbs_data->cdata->governor == GOV_CONSERVATIVE) {
 		struct cs_dbs_tuners *cs_tuners = dbs_data->tuners;
 		cs_tuners->sampling_rate = sampling_rate;
+	} else if (dbs_data->cdata->governor == GOV_ELEMENTALX) {
+ 		struct ex_dbs_tuners *ex_tuners = dbs_data->tuners;
+ 		ex_tuners->sampling_rate = sampling_rate;
+	} else if (dbs_data->cdata->governor == GOV_ZZMOOVE) {
+		struct zz_dbs_tuners *zz_tuners = dbs_data->tuners;
+		zz_tuners->sampling_rate = sampling_rate;
 	} else {
 		struct od_dbs_tuners *od_tuners = dbs_data->tuners;
 		od_tuners->sampling_rate = sampling_rate;
@@ -245,9 +259,13 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 	struct dbs_data *dbs_data;
 	struct od_cpu_dbs_info_s *od_dbs_info = NULL;
 	struct cs_cpu_dbs_info_s *cs_dbs_info = NULL;
+	struct ex_cpu_dbs_info_s *ex_dbs_info = NULL;
+	struct zz_cpu_dbs_info_s *zz_dbs_info = NULL;
 	struct od_ops *od_ops = NULL;
 	struct od_dbs_tuners *od_tuners = NULL;
 	struct cs_dbs_tuners *cs_tuners = NULL;
+	struct ex_dbs_tuners *ex_tuners = NULL;
+	struct zz_dbs_tuners *zz_tuners = NULL;
 	struct cpu_dbs_common_info *cpu_cdbs;
 	unsigned int sampling_rate, latency, ignore_nice, j, cpu = policy->cpu;
 	int io_busy = 0;
@@ -278,7 +296,15 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 
 		dbs_data->cdata = cdata;
 		dbs_data->usage_count = 1;
-		rc = cdata->init(dbs_data);
+
+		if (cdata->governor == GOV_ELEMENTALX) {
+			rc = cdata->init_ex(dbs_data, policy);
+
+		} else if (cdata->governor == GOV_ZZMOOVE) {
+			rc = cdata->init_zz(dbs_data, policy);
+		} else
+			rc = cdata->init(dbs_data);
+
 		if (rc) {
 			pr_err("%s: POLICY_INIT: init() failed\n", __func__);
 			kfree(dbs_data);
@@ -317,6 +343,15 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 					CPUFREQ_TRANSITION_NOTIFIER);
 		}
 
+		if ((cdata->governor == GOV_ZZMOOVE) &&
+				(!policy->governor->initialized)) {
+			struct zz_ops *zz_ops = dbs_data->cdata->gov_ops;
+
+			cpufreq_register_notifier(zz_ops->notifier_block,
+					CPUFREQ_TRANSITION_NOTIFIER);
+		}
+
+
 		if (!have_governor_per_policy())
 			cdata->gdbs_data = dbs_data;
 
@@ -337,6 +372,14 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 						CPUFREQ_TRANSITION_NOTIFIER);
 			}
 
+			if ((dbs_data->cdata->governor == GOV_ZZMOOVE) &&
+				(policy->governor->initialized == 1)) {
+				struct zz_ops *zz_ops = dbs_data->cdata->gov_ops;
+
+				cpufreq_unregister_notifier(zz_ops->notifier_block,
+						CPUFREQ_TRANSITION_NOTIFIER);
+			}
+
 			cdata->exit(dbs_data);
 			kfree(dbs_data);
 			cdata->gdbs_data = NULL;
@@ -353,6 +396,16 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		cs_dbs_info = dbs_data->cdata->get_cpu_dbs_info_s(cpu);
 		sampling_rate = cs_tuners->sampling_rate;
 		ignore_nice = cs_tuners->ignore_nice_load;
+	} else if (dbs_data->cdata->governor == GOV_ELEMENTALX) {
+ 		ex_tuners = dbs_data->tuners;
+ 		ex_dbs_info = dbs_data->cdata->get_cpu_dbs_info_s(cpu);
+ 		sampling_rate = ex_tuners->sampling_rate;
+ 		ignore_nice = ex_tuners->ignore_nice_load;
+	} else if (dbs_data->cdata->governor == GOV_ZZMOOVE) {
+		zz_tuners = dbs_data->tuners;
+		zz_dbs_info = dbs_data->cdata->get_cpu_dbs_info_s(cpu);
+		sampling_rate = zz_tuners->sampling_rate;
+		ignore_nice = zz_tuners->ignore_nice_load;
 	} else {
 		od_tuners = dbs_data->tuners;
 		od_dbs_info = dbs_data->cdata->get_cpu_dbs_info_s(cpu);
@@ -397,6 +450,13 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 			cs_dbs_info->down_skip = 0;
 			cs_dbs_info->enable = 1;
 			cs_dbs_info->requested_freq = policy->cur;
+		} else if (dbs_data->cdata->governor == GOV_ELEMENTALX) {
+ 			ex_dbs_info->down_floor = 0;
+ 			ex_dbs_info->enable = 1;
+		} else if (dbs_data->cdata->governor == GOV_ZZMOOVE) {
+			zz_dbs_info->down_skip = 0;
+			zz_dbs_info->enable = 1;
+			zz_dbs_info->requested_freq = policy->cur;
 		} else {
 			od_dbs_info->rate_mult = 1;
 			od_dbs_info->sample_type = OD_NORMAL_SAMPLE;
@@ -416,6 +476,12 @@ int cpufreq_governor_dbs(struct cpufreq_policy *policy,
 		if (dbs_data->cdata->governor == GOV_CONSERVATIVE)
 			cs_dbs_info->enable = 0;
 
+		if (dbs_data->cdata->governor == GOV_ELEMENTALX)
+ 			ex_dbs_info->enable = 0;
+ 
+		if (dbs_data->cdata->governor == GOV_ZZMOOVE)
+			zz_dbs_info->enable = 0;
+
 		gov_cancel_work(dbs_data, policy);
 
 		mutex_lock(&dbs_data->mutex);
diff --git a/drivers/cpufreq/cpufreq_governor.h b/drivers/cpufreq/cpufreq_governor.h
index cc401d14..ebda3397 100644
--- a/drivers/cpufreq/cpufreq_governor.h
+++ b/drivers/cpufreq/cpufreq_governor.h
@@ -126,6 +126,8 @@ static void *get_cpu_dbs_info_s(int cpu)				\
  * cdbs: common dbs
  * od_*: On-demand governor
  * cs_*: Conservative governor
+ * ex_*: ElementalX governor
+ * zz_*: ZZMoove governor
  */
 
 /* Per cpu structures */
@@ -169,6 +171,21 @@ struct cs_cpu_dbs_info_s {
 	unsigned int enable:1;
 };
 
+struct ex_cpu_dbs_info_s {
+ 	struct cpu_dbs_common_info cdbs;
+ 	unsigned int down_floor;
+ 	unsigned int enable:1;
+};
+ 
+
+struct zz_cpu_dbs_info_s {
+	struct cpu_dbs_common_info cdbs;
+	unsigned int down_skip;
+	unsigned int requested_freq;
+	unsigned int enable:1;
+};
+
+
 /* Per policy Governors sysfs tunables */
 struct od_dbs_tuners {
 	unsigned int ignore_nice_load;
@@ -188,12 +205,40 @@ struct cs_dbs_tuners {
 	unsigned int freq_step;
 };
 
+struct ex_dbs_tuners {
+ 	unsigned int ignore_nice_load;
+ 	unsigned int sampling_rate;
+ 	unsigned int up_threshold;
+ 	unsigned int down_differential;
+ 	unsigned int active_floor_freq;
+ 	unsigned int sampling_down_factor;
+ 	unsigned int powersave;
+}; 
+
+struct zz_dbs_tuners {
+ 	unsigned int ignore_nice_load;
+ 	unsigned int sampling_rate;
+ 	unsigned int sampling_down_factor;
+ 	unsigned int up_threshold;
+ 	unsigned int down_threshold;
+ 	unsigned int smooth_up;
+ 	unsigned int scaling_proportional;
+ 	unsigned int fast_scaling_up;
+ 	unsigned int fast_scaling_down;
+ 	unsigned int afs_threshold1;
+ 	unsigned int afs_threshold2;
+ 	unsigned int afs_threshold3;
+ 	unsigned int afs_threshold4;
+ };
+
 /* Common Governor data across policies */
 struct dbs_data;
 struct common_dbs_data {
 	/* Common across governors */
 	#define GOV_ONDEMAND		0
 	#define GOV_CONSERVATIVE	1
+	#define GOV_ELEMENTALX		2
+	#define GOV_ZZMOOVE		3
 	int governor;
 	struct attribute_group *attr_group_gov_sys; /* one governor - system */
 	struct attribute_group *attr_group_gov_pol; /* one governor - policy */
@@ -209,6 +254,8 @@ struct common_dbs_data {
 	void (*gov_dbs_timer)(struct work_struct *work);
 	void (*gov_check_cpu)(int cpu, unsigned int load);
 	int (*init)(struct dbs_data *dbs_data);
+	int (*init_ex)(struct dbs_data *dbs_data, struct cpufreq_policy *policy);
+	int (*init_zz)(struct dbs_data *dbs_data, struct cpufreq_policy *policy);
 	void (*exit)(struct dbs_data *dbs_data);
 
 	/* Governor specific ops, see below */
@@ -219,6 +266,18 @@ struct common_dbs_data {
 struct dbs_data {
 	struct common_dbs_data *cdata;
 	unsigned int min_sampling_rate;
+	struct cpufreq_frequency_table *freq_table;
+	bool freq_table_desc;
+ 	unsigned int freq_table_size;
+ 	unsigned int pol_min;
+ 	unsigned int pol_max;
+ 	unsigned int min_scaling_freq;
+ 	unsigned int limit_table_start;
+ 	unsigned int limit_table_end;
+ 	unsigned int max_scaling_freq_hard;
+ 	unsigned int max_scaling_freq_soft;
+ 	unsigned int scaling_mode_up;
+ 	unsigned int scaling_mode_down;
 	int usage_count;
 	void *tuners;
 
@@ -238,6 +297,10 @@ struct cs_ops {
 	struct notifier_block *notifier_block;
 };
 
+struct zz_ops {
+ 	struct notifier_block *notifier_block;
+ };
+
 static inline int delay_for_sampling_rate(unsigned int sampling_rate)
 {
 	int delay = usecs_to_jiffies(sampling_rate);
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 56ea8a33..52831eb2 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -486,6 +486,12 @@ extern struct cpufreq_governor cpufreq_gov_conservative;
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
 extern struct cpufreq_governor cpufreq_gov_interactive;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE)
+extern struct cpufreq_governor cpufreq_gov_zzmoove;
+#define CPUFREQ_DEFAULT_GOVERNOR       (&cpufreq_gov_zzmoove)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_NIGHTMARE)
+extern struct cpufreq_governor cpufreq_gov_nightmare;
+#define CPUFREQ_DEFAULT_GOVERNOR (&cpufreq_gov_nightmare)
 #endif
 
 /*********************************************************************
